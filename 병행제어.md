## 병행 제어(Concurrency Control)

### 병행 제어(Concurrency Control)란?

병행(Concurrency)은 매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식이다. 

따라서 실제로는 한 번에 한 트랜잭션만 수행하지만, 마치 동시에 여러 트랜잭션을 수행하는 것처럼 보이도록 하는 것이다. 

병행 제어(Concurrency Control)는 이렇게 트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 말한다. 

병행 제어의 목적은 다음과 같다.  

    - 데이터베이스의 일관성 유지
    - 데이터베이스 공유 최대화
    - 시스템 활용도 최대화
    - 사용자 응답 시간 최소화
    - 단위 시간당 트랜잭션 처리 건수 최대화

### 병행의 문제점

병행 제어를 하지 않고, 트랜잭션들이 동시에 데이터베이스에 접근할 수 있다면 여러 문제점이 발생한다. 

1. 갱신 분실 (Lost Update)

    갱신 분실은 같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과의 일부가 없어지는 현상이다. 

 

2. 모순성

    모순성은 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것을 의미한다. 

 

3. 연쇄복귀

    같은 자원을 사용하는 두개의 트랜잭션 중 한 개의 트랜잭션이 성공적으로 일을 수행하였다 하더라도 다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두가 복귀되는 현상

 

4. 비완료 의존성

    하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상을 말한다. 

### 병행 제어 기법
#### 1.로킹(Locking)

로킹은 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법이다.<br/>
데이터베이스에서의 로킹(Locking) 단위란 말 그대로 "잠그는 단위"를 말 한다. 
한 번에 로킹 할 수 있는 데이터의 크기를 로킹 단위라고 하며 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 로킹 단위가 될 수 있다. 
로크는 이때 사용하는 데이터 객체이다.

    로킹 단위가 크면 -> 로크의 수가 적어진다. -> 제어 기법이 간단해 진다. -> 병행성 수준이 낮아진다.
    로킹 단위가 작으면 -> 로크의 수가 많아진다. -> 제어 하기 까다롭다. -> 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다. 
    
기본적으로 로킹은 lock과 unlock 연산을 사용한다. 로킹 규약은 다음과 같다. 
    
    1) 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.

    2) 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.

    3) 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.

    4) 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.


* 로킹 연산의 종류<br/>

  로킹 연산은 데이터에 대한 연산의 성격에 따라 공유잠금(Shared lock: S-lock)과 배타잠금(Exclusive lock: X-lock)으로 나눌 수 있다.
  
  모든 트랜잭션은 데이터 항목에 대한 접근을 시도할 때 둘 중 하나의 잠금 방법을 사용한다. 공유잠금과 배타잠금 모두 잠금을 해제할 경우에는 unlock 연산을 이용한다.
  
 
 <br/>
 
    S-lock(공유잠금)
    
    - 공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다.

      ex) T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다.

    - 하나의 데이터 항목에 대해 여러 개의 공유잠금이(S-lock) 가능하다.

      ex) T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다.

    - 다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다.

      ex) T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다.
      
      
    X-lock(배타잠금)
    
    
    - 배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다.

      ex) T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다.

    - 하나의 데이터 항목에 대해서는 하나의 배타잠금(X-lock)만 가능하다.

    - 동시에 여러 개의 배타잠금은 불가능하다.

      ex) T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다.

    - 다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다.

      ex) T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다.



<br/>
      
* 로킹의 한계
  로킹은 대부분의 DBMS에서 사용되는 방식이지만 다음과 같은 한계가 존재한다.

    - 직렬 가능한 스케줄이 항상 보장되지 않는다 → 2단계 로킹 규약(2PL)으로 해결
    - 교착상태(deadlock)가 발생할 수 있다
   
  단순 로킹 연산만으로는 항상 직렬 가능한 스케줄을 보장하지 못하기 때문에 2단계 로킹 규약(2PL)을 사용하여 이를 해결한다.
      
#### 2. 타임스탬프(Time Stamp)

데이터에 접근하는 시간을 미리 정하여 정해진 시간의 순서대로 데이터에 접근하며 수행함, 직렬가능성을 보장하며 시간을 나눠 사용하기 때문에교착상태가 발생하지 않음, 하지만 연쇄복귀를 초래할 수 있음.

 

#### 3. 낙관적 병행제어(Optimistic Concurrency Control)

낙관적 병행 제어는 트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식이다. 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식이다. 

병행 수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read-only)인 경우, 트랜잭션 간 충돌률이 매우 낮기 때문에 병행 제어 기법을 사용하지 않고도 대부분 일관성을 유지한다는 점을 이용한 방식이다. 
 

#### 4. 다중 버전 병행제어(Multi-version Concurrency Control)

한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식이다. 타임스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 한다. 

여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택한다. 

충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점이 있다.
