트랜잭션(Transaction)
=====================

## 트랜젝션이란?

트랜젝션은 데이터베이스의 상태를 변화시키기 위한 **작업 수행의 논리적 단위**를 의미한다.

우리는 데이터베이스로 SQL 쿼리를 보냄으로써 데이터베이스의 **상태**를 변화시킨다. 그렇다면 **작업 단위**라는 것은 무엇을 말하는 것일까? **작업 단위**는 사용자가 특정 기능의 수행을 위해 SQL 작업을 묶은 단위를 의미한다.

>ex ) 송금 서비스를 예로 들어보자. 송금 서비스는 **1. A가 돈을 보내고, 2. B가 그 돈을 안전하게 받았을때** 완전히 실행이 됐다고 할 수 있다. 두 과정이 다른 트랜젝션, 즉 다른 작업으로 분리되었다고 생각해보자.<br/><br/>
>A가 돈을 10000원 송금하면 A의 돈 데이터에서 10000원이 차감될 것이다. 그에 맞춰서 B의 잔고는 10000원이 추가 될 것이다. 만약 A의 로직에서 오류가 발생해 트랜젝션 rollback이 일어난다면 A의 돈 데이터는 다시 10000원이 추가됨으로써 원상복구가 될 것이다. 그치만 B의 돈은 어떠한가? 다른 트랜젝션으로 분류되었기에 아무런 rollback도 일어나지 않기 때문에 **돈이 추가된 상태로 남게 된다.**<br/><br/>
>송금 과정을 하나의 작업 단위로 묶지 않으면 당사자들간의 데이터 불일치가 나타날 수 있다. 우리는 두 과정을 **하나의 트랜젝션**으로 묶어야 한다. 그래야 중간에 문제가 발생해도 두 과정 모두 rollback이 일어날 수 있다.

이처럼 작업 단위를 잘 설정하는 것은 서비스를 구성함에 있어서 매우 중요한 부분이다. 트랜젝션이 성공적으로 마무리 되었다면 **commit**을 호출해서 수정 사항을 DB에 영구적으로 반영하고, 중간에 오류가 발생했다면 **rollback**을 호출해서 트랜젝션 내부의 모든 작업을 원상복구 시킨다.

**DBMS의 성능은 초당 트랜잭션의 실행 수**( **TPS** : Transaction per second )로 측정한다.<br/><br/><br/><br/>
## 트랜젝션의 특성 (ACID)

트랜젝션은 ACID라는 4가지의 특성을 만족해야 한다.

### 원자성(Automicity)

1. 트랜젝션 내부에서 실행된 작업들은 모두 성공해서 commit이 되거나, 문제가 발생한다면 rollback을 통해 모두 취소되야 한다. 즉 작업 중 일부분만 성공 할 수 없다. 위의 송금서비스의 예시가 원자성에 대한 설명이다.

2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

### 일관성(Consistency)

1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

트랜젝션 전 후의 데이터베이스의 상태가 **Correct State**여야 한다고 하는데, Correct State는 도메인의 유효범위, 무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태를 의미한다.

예를 들어 데이터 타입이 정수형이라면 트랜젝션 이후에도 정수형으로 유지되어야 하며, null값을 제한해놓은 컬럼에 null값이 들어가 있으면 안된다. 또한 연관관계에서 변경이 일어났으면 외래키 값도 정상적으로 변경되어야 한다. 이런 제약조건을 변함없이 만족해야 일관성을 유지한 것이다.

### 격리성(Isolation)

1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

격리성의 경우에는 완전히 보장하려면 각각의 트랜젝션을 순서대로 처리해야한다.<br/>
이는 동시성 처리 성능을 매우 나쁘게 한다. 따라서 격리성의 수준을 여러 단계로 나눠놓았다.

 * READ UNCOMMITED<br/>
 상대방에 커밋하지 않은 데이터를 읽을 수 있다. 예를 들어 사용자 A가 트랜젝션 내에서 데이터를 수정하고 있는데 사용자 B가 그 데이터를 조회할 수 있다. 커밋되지 않은 데이터를 조회하는걸 Dirty Read라고 말한다. 사용자 B가 데이터를 사용하는 도중에 사용자A가 데이터를 롤백시켜 버리면 데이터 정합성이 깨질 수 있다.
 
 * READ COMMITED<br/>
 RDB에서 대부분 기본적으로 사용되고 있는 격리 수준이다. 상대방이 커밋한 데이터만 조회할 수 있다. 따라서 Dirty Read는 발생하지 않는다. 하지만 NON-REPEATABLE READ가 발생할 수 있다. 예를 들어 사용자A가 커밋한 데이터를 사용자B가 트랜젝션 내에서 조회하고 있는데 이후에 사용자 A가 데이터를 수정 후 다시 커밋한다면 사용자B는 같은 트랜젝션 내에서 다른 데이터를 조회하게 되는 것이다. 따라서 하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 REPEATABLE READ의 정합성에 어긋난다.

 * REPEATABLE READ<br/>
 한번 조회한 데이터는 트랜젝션 내에서 다시 조회해도 같은 데이터가 나오는게 보장된다. 하지만 PHANTOM READ가 발생할 수 있다. 예를 들어 사용자A가 트랜젝션 내에서 20살 이하의 회원 리스트를 조회했을때, 중간에 사용자B가 회원을 20살 이하 회원을 한명 추가한다면, 다시 리스트를 조회했을때 나오는 결과가 달라질 수 있다. 이처럼 결과 집합이 달라지는 것을 PHANTOM READ라고 한다. (select해왔을때는 추가된 데이터가 보이지 않는데, count를 하면 보이지 않는 데이터가 count되어 나온다)
 
 * SERIALIZABLE<br/>
 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준. 성능 측면에서는 동시 처리성능이 가장 낮다.
### 지속성(Durability)

1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

중간에 시스템 문제가 발생했을때 데이터베이스 로그를 참고해서 성공했던 트랜젝션을 복구 할 수 있다.
