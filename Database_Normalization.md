# 정규화 (Normalization)  

정규화 (Normalization) 는 관계형 데이터베이스를 디자인하는 한 방법으로, 불필요한 중복없이 정보를 저장하도록 스키마를 구성하는 것이다. 
그리고 이상 현상이 일어나지 않도록 스키마를 분해한다. 단 분해의 과정에서 정보의 손실이 없어야 한다. (lossless decomposition) 
  

## 제 1 정규형 (1NF) 

각 컬럼이 원자값을 가져야 한다. 
각 컬럼은 같은 종류나 타입의 값을 가져야 한다. 
각 컬럼은 unique한 이름을 가져야 한다. 
칼럼의 순서가 상관없어야 한다.
![스크린샷 2023-01-23 오후 2 42 03](https://user-images.githubusercontent.com/41604678/213973392-b4389585-817f-44fd-9fe5-d0eda3f4bd79.png)  
다음과 같은 테이블에서는 '과목' 컬럼이 원자값을 가지고 있지 않다. 따라서 제 1 정규형 과정을 거치면 다음과 같이 분해할 수 있다.   
![스크린샷 2023-01-23 오후 2 42 36](https://user-images.githubusercontent.com/41604678/213973408-be5a38ed-ffaf-4993-9df8-a8371fe4d1ed.png)

## 제 2 정규형 (2NF)

* 1NF를 만족해야 한다. 
* 모든 컬럼이 완전 함수 종속을 만족해야 한다. (== 부분적 종속이 없어야 한다. )
* 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어서는 안된다는 것이다. 즉, 기본키 중에 어떤 요소가 특정 컬럼에 종속되어서는 안된다.

![image](https://user-images.githubusercontent.com/41604678/213974691-1042b503-49e2-4de3-9869-6f8b09160426.png)

위의 테이블에서는 한 학생의 해당 과목에 대한 성적을 조회하기 위해서, 학번과 과목을 알아야 성적을 조회할 수 있다. 따라서 이 경우 테이블에서 기본키(Primary Key)는 (학생번호, 과목) 으로 이루어진 복합키이다. 

![스크린샷 2023-01-23 오후 2 59 16](https://user-images.githubusercontent.com/41604678/213974775-e267b719-b979-4e7c-ab9a-0dc32562341c.png)

그런데, 지도교수의 경우 과목을 알면 바로 누구인지 값을 알 수 있다. 즉, 지도교수가 과목 컬럼에 종속되는 현상을 보이고 있다. 

![스크린샷 2023-01-23 오후 2 59 19](https://user-images.githubusercontent.com/41604678/213974770-8c42d5ee-b005-4c71-a0bd-44589a582ac6.png)

따라서 제 2 정규형을 거치면 다음과 같이 분해된다.  
![image](https://user-images.githubusercontent.com/41604678/213974875-ecc235bb-f0a0-45db-83c5-db4db26d5ede.png)
  

## 제 3 정규형 (3NF)

* 2NF를 만족해야 한다. (== 제1정규형 + 제2정규형을 우선 만족하는 상태). 
* 기본키를 제외한 속성들 간 이행 종속성(Transitive Dependency)이 없어야 한다. 
* 이행 종속성 : A→B 이고 B→C 일때 A→C가 성립하는 상태를 이행 종속성이라고 한다.  
![image](https://user-images.githubusercontent.com/41604678/213977960-ac4e5239-4cbd-4977-a9a9-0a32e553cf7b.png)   

위의 경우, ID를 알면 등급을 알 수 있고, 등급을 알면 할인율을 알 수 있다.  

![image](https://user-images.githubusercontent.com/41604678/213978058-bf53b09d-8421-4971-8034-59f83c826cf7.png)  
즉, ID -> 등급, 등급 -> 할인율이며 ID -> 할인율 이라는 이행 종속성이 발생한다. 

3NF를 만족하기 위해서 다음과 같이 릴레이션을 분해한다.  

![image](https://user-images.githubusercontent.com/41604678/213978161-053b2573-d610-45fb-b2a4-e7536637d1d2.png) 
![image](https://user-images.githubusercontent.com/41604678/213978172-cab5b98d-cf8c-4892-850d-6e51f4c39ed4.png)  


## BCNF (Boyce-Codd Normal Form)

* 제 3 정규형을 더 강화한 정규화 과정이다. 함수적 종속성에 의해 발생하는 모든 중복을 제거한다.  
* 모든 결정자가 후보키 집합에 속해야 한다. 이것을 달리 말하면, 후보키 집합에 없는 컬럼이 결정자가 되면 안된다는 의미이다. 결정자는 (a→b 에서 a를 의미함)  

다음과 같은 테이블이 있다고 하자.  

![image](https://user-images.githubusercontent.com/41604678/213978308-5e8ae204-6846-4fd8-a613-ecc399a03774.png)   

이 테이블에서 PK는 학번과 과목이며, 학번과 과목을 알면 담당교수를 조회할 수 있다.  
![image](https://user-images.githubusercontent.com/41604678/213978592-10241b8d-b644-40d3-83df-78ab4f3ba90b.png)   

과목을 알면 담당교수를 알 수 있는 것처럼 과목이 담당교수를 결정하는 것같지만,  
![image](https://user-images.githubusercontent.com/41604678/213978650-2e2337ea-3440-48ee-ab76-0e42d9f32089.png)  
같은 과목 (알고리즘)을 가르치는 담당교수가 여러명 존재할 수 있으므로 과목 -> 담당교수를 만족시키지 않는다.  

반면 담당교수를 알면 이 교수가 어떤 과목을 담당하는지 알 수 있다.  
![image](https://user-images.githubusercontent.com/41604678/213978716-ded52423-d8df-4e7a-9d2f-21c9b1eb12cf.png)  
즉, 이 테이블에서 담당교수가 과목의 결정자가 되어버리며, 지도교수는 기본키 (후보키) 집합에 속하지 않으므로 BCNF를 만족하지 않는다.

BCNF 정규형을 만족시키려면 다음과 같이 분해해야 한다. 
![image](https://user-images.githubusercontent.com/41604678/213978795-8db39219-d279-4d8b-a50a-5dcbf8da023e.png)  

## 반정규화 

* 정규화의 단점은 릴레이션의 분해로 JOIN 연산이 증가할 수 있다는 것이다. JOIN 연산이 많이 발생하게 되면 성능 저하 문제가 발생할 것이며, 이를 해결하기 위해 중복을 허용하는 반정규화를 적용할 수 있다.
* 반정규화는 select 문과 같은 조회를 할 때 효율적으로 처리할 수 있으나, 릴레이션의 관계가 유연하지 못하다는 단점이 있다. 

## KEY 종류 

* 슈퍼키 (Super Key) : 테이블에서 각 행을 유일하게 식별할 수 있는 하나이상의 속성들의 집합  

* 후보키 (Candidate Key) : 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다. 후보키는 기본키가 될 수 있는 후보이다. 후보키는 슈퍼키와 달리, 유일성과 최소성을 만족해야 한다.   

* 기본키 (Primary Key): 후보키들 중에서 선택한 키로, 최소성과 유일성을 만족한다. 테이블에서 각 튜플들을 구별하는 용도로 쓰이며, 기본키는 오직 1개이다. NULL 값을 허용하지 않으며, 중복 값을 허용하지 않는다.   

* 대체키 (Alternative Key) : 후보키가 두개 이상일 경우 어느 하나를 PK로 정하고 남은 후보키들을 대체키라고 한다.   

* 외래키 (Foreign Key) : 다른 테이블의 데이터를 참조하기 위해 외래키를 사용하여 조회한다. 참조될 열의 값은 참조되는 테이블에서 기본키여야 한다. 외래키를 통해 다른 테이블의 데이터를 참조할 때 없는 값을 참조하지 않도록 제약을 준다.  
