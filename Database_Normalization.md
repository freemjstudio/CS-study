# 정규화 (Normalization)  

정규화 (Normalization) 는 관계형 데이터베이스를 디자인하는 한 방법으로, 불필요한 중복없이 정보를 저장하도록 스키마를 구성하는 것이다. 
그리고 이상 현상이 일어나지 않도록 스키마를 분해한다. 단 분해의 과정에서 정보의 손실이 없어야 한다. (lossless decomposition) 
  

## 제 1 정규형 (1NF) 

각 컬럼이 원자값을 가져야 한다. 
각 컬럼은 같은 종류나 타입의 값을 가져야 한다. 
각 컬럼은 unique한 이름을 가져야 한다. 
칼럼의 순서가 상관없어야 한다.
![스크린샷 2023-01-23 오후 2 42 03](https://user-images.githubusercontent.com/41604678/213973392-b4389585-817f-44fd-9fe5-d0eda3f4bd79.png)  
다음과 같은 테이블에서는 '과목' 컬럼이 원자값을 가지고 있지 않다. 따라서 제 1 정규형 과정을 거치면 다음과 같이 분해할 수 있다.   
![스크린샷 2023-01-23 오후 2 42 36](https://user-images.githubusercontent.com/41604678/213973408-be5a38ed-ffaf-4993-9df8-a8371fe4d1ed.png)

## 제 2 정규형 (2NF)

* 1NF를 만족해야 한다. 
* 모든 컬럼이 완전 함수 종속을 만족해야 한다. (== 부분적 종속이 없어야 한다. )
* 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어서는 안된다는 것이다. 즉, 기본키 중에 어떤 요소가 특정 컬럼에 종속되어서는 안된다.

![image](https://user-images.githubusercontent.com/41604678/213974691-1042b503-49e2-4de3-9869-6f8b09160426.png)

위의 테이블에서는 한 학생의 해당 과목에 대한 성적을 조회하기 위해서, 학번과 과목을 알아야 성적을 조회할 수 있다. 따라서 이 경우 테이블에서 기본키(Primary Key)는 (학생번호, 과목) 으로 이루어진 복합키이다. 

![스크린샷 2023-01-23 오후 2 59 16](https://user-images.githubusercontent.com/41604678/213974775-e267b719-b979-4e7c-ab9a-0dc32562341c.png)

그런데, 지도교수의 경우 과목을 알면 바로 누구인지 값을 알 수 있다. 즉, 지도교수가 과목 컬럼에 종속되는 현상을 보이고 있다. 

![스크린샷 2023-01-23 오후 2 59 19](https://user-images.githubusercontent.com/41604678/213974770-8c42d5ee-b005-4c71-a0bd-44589a582ac6.png)

따라서 제 2 정규형을 거치면 다음과 같이 분해된다.  
![image](https://user-images.githubusercontent.com/41604678/213974875-ecc235bb-f0a0-45db-83c5-db4db26d5ede.png)
  

## 제 3 정규형 (3NF)

* 2NF를 만족해야 한다. (== 제1정규형 + 제2정규형을 우선 만족하는 상태). 
* 기본키를 제외한 속성들 간 이행 종속성(Transitive Dependency)이 없어야 한다. 
* 이행 종속성 : A→B 이고 B→C 일때 A→C가 성립하는 상태를 이행 종속성이라고 한다.  



## BCNF (Boyce-Codd Normal Form)

* 제 3 정규형을 더 강화한 정규화 과정이다. 함수적 종속성에 의해 발생하는 모든 중복을 제거한다.  
* 모든 결정자가 후보키 집합에 속해야 한다. 이것을 달리 말하면, 후보키 집합에 없는 컬럼이 결정자가 되면 안된다는 의미이다. 결정자는 (a→b 에서 a를 의미함)
  
예시에서는 지도교수가 과목의 결정자가 되어버리며, 지도교수는 기본키 (후보키) 집합에 속하지 않으므로 BCNF를 만족하지 않는다. 

BCNF 정규형을 만족시키려면 다음과 같이 분해해야 한다. 

## 반정규화 

* 정규화의 단점 : 릴레이션의 분해로 JOIN 연산이 증가할 수 있다. JOIN 연산이 많이 발생하게 되면 성능 저하 문제를 해결하기 위해 반정규화를 적용할 수 있다.

## KEY 종류 

* 슈퍼키 (Super Key) : 테이블에서 각 행을 유일하게 식별할 수 있는 하나이상의 속성들의 집합  

* 후보키 (Candidate Key) : 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다. 후보키는 기본키가 될 수 있는 후보이다. 후보키는 슈퍼키와 달리, 유일성과 최소성을 만족해야 한다.   

* 기본키 (Primary Key): 후보키들 중에서 선택한 키로, 최소성과 유일성을 만족한다. 테이블에서 각 튜플들을 구별하는 용도로 쓰이며, 기본키는 오직 1개이다. NULL 값을 허용하지 않으며, 중복 값을 허용하지 않는다.   

* 대체키 (Alternative Key) : 후보키가 두개 이상일 경우 어느 하나를 PK로 정하고 남은 후보키들을 대체키라고 한다.   

* 외래키 (Foreign Key) : 다른 테이블의 데이터를 참조하기 위해 외래키를 사용하여 조회한다. 참조될 열의 값은 참조되는 테이블에서 기본키여야 한다. 외래키를 통해 다른 테이블의 데이터를 참조할 때 없는 값을 참조하지 않도록 제약을 준다.  
